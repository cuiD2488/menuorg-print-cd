<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ğŸ–¨ï¸ Electronç¯å¢ƒçƒ­æ•æ‰“å°æœºæµ‹è¯•</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',
          'Microsoft YaHei', sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        font-weight: 700;
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .status-bar {
        background: #f8f9fa;
        padding: 15px 30px;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .env-status {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .env-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #dc3545;
      }

      .env-indicator.electron {
        background: #28a745;
      }

      .main-content {
        padding: 30px;
      }

      .section {
        margin-bottom: 40px;
        padding: 25px;
        border: 1px solid #e9ecef;
        border-radius: 10px;
        background: #fff;
      }

      .section h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        font-size: 1.8em;
        border-bottom: 3px solid #3498db;
        padding-bottom: 10px;
      }

      .button-group {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: none;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-success {
        background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
        color: #2c3e50;
      }

      .btn-warning {
        background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        color: #2c3e50;
      }

      .btn-danger {
        background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        color: #2c3e50;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .result-area {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
        line-height: 1.5;
      }

      .printer-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .printer-card {
        border: 1px solid #e9ecef;
        border-radius: 10px;
        padding: 20px;
        background: #fff;
      }

      .printer-name {
        font-weight: bold;
        font-size: 1.1em;
        color: #2c3e50;
        margin-bottom: 10px;
      }

      .printer-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        color: #6c757d;
      }

      .test-controls {
        display: grid;
        grid-template-columns: 1fr 200px 120px;
        gap: 15px;
        align-items: center;
        margin-bottom: 20px;
      }

      .test-controls input,
      .test-controls select {
        padding: 10px;
        border: 1px solid #ced4da;
        border-radius: 5px;
        font-size: 14px;
      }

      .encoding-results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .encoding-card {
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
      }

      .encoding-score {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .score-excellent {
        color: #28a745;
      }
      .score-good {
        color: #ffc107;
      }
      .score-fair {
        color: #fd7e14;
      }
      .score-poor {
        color: #dc3545;
      }

      .alert {
        padding: 15px 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        border-left: 4px solid;
      }

      .alert-info {
        background: #e7f3ff;
        border-color: #3498db;
        color: #2c3e50;
      }

      .alert-warning {
        background: #fff3cd;
        border-color: #ffc107;
        color: #856404;
      }

      .alert-success {
        background: #d4edda;
        border-color: #28a745;
        color: #155724;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: #e9ecef;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        transition: width 0.3s ease;
      }

      .log-entry {
        margin-bottom: 5px;
        padding: 5px 0;
      }

      .log-success {
        color: #28a745;
      }
      .log-error {
        color: #dc3545;
      }
      .log-warning {
        color: #ffc107;
      }
      .log-info {
        color: #17a2b8;
      }

      @media (max-width: 768px) {
        .container {
          margin: 10px;
          border-radius: 10px;
        }

        .main-content {
          padding: 20px;
        }

        .test-controls {
          grid-template-columns: 1fr;
        }

        .button-group {
          flex-direction: column;
        }

        .btn {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ–¨ï¸ Electronç¯å¢ƒçƒ­æ•æ‰“å°æœºæµ‹è¯•</h1>
        <p>åŸºäºTauriåç«¯çš„çœŸå®æ‰“å°æœºAPIæµ‹è¯•å¹³å°</p>
      </div>

      <div class="status-bar">
        <div class="env-status">
          <div class="env-indicator" id="envIndicator"></div>
          <span id="envStatus">æ£€æµ‹è¿è¡Œç¯å¢ƒä¸­...</span>
        </div>
        <div>
          <span id="printerCount">æ‰“å°æœº: æœªæ£€æµ‹</span>
        </div>
      </div>

      <div class="main-content">
        <!-- ç¯å¢ƒæ£€æµ‹å’Œåˆå§‹åŒ– -->
        <div class="section">
          <h2>ğŸ”§ ç¯å¢ƒæ£€æµ‹ä¸åˆå§‹åŒ–</h2>
          <div class="alert alert-info" id="environmentAlert">
            æ­£åœ¨æ£€æµ‹è¿è¡Œç¯å¢ƒ...
          </div>

          <div class="button-group">
            <button class="btn btn-primary" onclick="initializeSystem()">
              ğŸš€ åˆå§‹åŒ–ç³»ç»Ÿ
            </button>
            <button class="btn btn-success" onclick="refreshPrinters()">
              ğŸ”„ åˆ·æ–°æ‰“å°æœº
            </button>
            <button class="btn btn-warning" onclick="checkElectronAPIs()">
              ğŸ” æ£€æŸ¥APIå¯ç”¨æ€§
            </button>
          </div>

          <div class="result-area" id="initResult">ç­‰å¾…åˆå§‹åŒ–...</div>
        </div>

        <!-- æ‰“å°æœºç®¡ç† -->
        <div class="section">
          <h2>ğŸ–¨ï¸ æ‰“å°æœºç®¡ç†</h2>
          <div class="printer-grid" id="printerGrid">
            <div class="printer-card">
              <div class="printer-name">ç­‰å¾…æ£€æµ‹æ‰“å°æœº...</div>
            </div>
          </div>

          <div class="button-group">
            <button class="btn btn-primary" onclick="testSelectedPrinter()">
              ğŸ§ª æµ‹è¯•é€‰ä¸­æ‰“å°æœº
            </button>
            <button class="btn btn-success" onclick="debugSelectedPrinter()">
              ğŸ”§ è°ƒè¯•æ‰“å°æœº
            </button>
          </div>
        </div>

        <!-- ä¸­æ–‡ç¼–ç æµ‹è¯• -->
        <div class="section">
          <h2>ğŸˆ¶ ä¸­æ–‡ç¼–ç å…¼å®¹æ€§æµ‹è¯•</h2>

          <div class="test-controls">
            <input
              type="text"
              id="testText"
              placeholder="è¾“å…¥æµ‹è¯•æ–‡æœ¬"
              value="æµ‹è¯•ä¸­æ–‡æ‰“å°ï¼šè€ç‹å·èœé¦† - éº»å©†è±†è… ï¿¥18.99"
            />
            <select id="encodingSelect">
              <option value="">é€‰æ‹©ç¼–ç </option>
              <option value="UTF8">UTF-8</option>
              <option value="GBK">GBK</option>
              <option value="GB18030">GB18030</option>
              <option value="BIG5">Big5</option>
              <option value="GB2312">GB2312</option>
            </select>
            <button class="btn btn-primary" onclick="testSingleEncoding()">
              æµ‹è¯•ç¼–ç 
            </button>
          </div>

          <div class="button-group">
            <button class="btn btn-success" onclick="testAllEncodings()">
              ğŸ”„ æ‰¹é‡æµ‹è¯•æ‰€æœ‰ç¼–ç 
            </button>
            <button
              class="btn btn-warning"
              onclick="generateCompatibilityReport()"
            >
              ğŸ“Š ç”Ÿæˆå…¼å®¹æ€§æŠ¥å‘Š
            </button>
            <button class="btn btn-danger" onclick="smartEncodingSelection()">
              ğŸ¤– æ™ºèƒ½ç¼–ç é€‰æ‹©
            </button>
          </div>

          <div class="encoding-results" id="encodingResults">
            <!-- ç¼–ç æµ‹è¯•ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
          </div>

          <div class="result-area" id="encodingTestResult">ç­‰å¾…ç¼–ç æµ‹è¯•...</div>
        </div>

        <!-- æ™ºèƒ½æ‰“å°æµ‹è¯• -->
        <div class="section">
          <h2>ğŸ¯ æ™ºèƒ½ç¼–ç æ‰“å°æµ‹è¯•</h2>

          <div class="alert alert-info">
            <strong>æ³¨æ„ï¼š</strong
            >æ™ºèƒ½æ‰“å°å°†è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç¼–ç å¹¶æ‰§è¡ŒçœŸå®æ‰“å°ã€‚è¯·ç¡®ä¿æ‰“å°æœºå·²è¿æ¥å¹¶æœ‰çº¸å¼ ã€‚
          </div>

          <div class="button-group">
            <button class="btn btn-primary" onclick="printTestOrder()">
              ğŸ–¨ï¸ æ‰“å°æµ‹è¯•è®¢å•
            </button>
            <button class="btn btn-success" onclick="printWithCustomEncoding()">
              âš™ï¸ æŒ‡å®šç¼–ç æ‰“å°
            </button>
            <button class="btn btn-warning" onclick="batchPrintTest()">
              ğŸ“¦ æ‰¹é‡æ‰“å°æµ‹è¯•
            </button>
          </div>

          <div class="result-area" id="printTestResult">ç­‰å¾…æ‰“å°æµ‹è¯•...</div>
        </div>

        <!-- ç³»ç»Ÿæ—¥å¿— -->
        <div class="section">
          <h2>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h2>

          <div class="button-group">
            <button class="btn btn-primary" onclick="clearLog()">
              ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—
            </button>
            <button class="btn btn-success" onclick="exportLog()">
              ğŸ’¾ å¯¼å‡ºæ—¥å¿—
            </button>
          </div>

          <div class="result-area" id="systemLog">ç³»ç»Ÿå°±ç»ªï¼Œç­‰å¾…æ“ä½œ...</div>
        </div>
      </div>
    </div>

    <script>
      let selectedPrinter = null;
      let printers = [];
      let lastTestResults = [];

      // åˆå§‹åŒ–é¡µé¢
      document.addEventListener('DOMContentLoaded', function () {
        detectEnvironment();
      });

      // ç¯å¢ƒæ£€æµ‹
      function detectEnvironment() {
        const isElectron = !!window.electronAPI;
        const indicator = document.getElementById('envIndicator');
        const status = document.getElementById('envStatus');
        const alert = document.getElementById('environmentAlert');

        if (isElectron) {
          indicator.classList.add('electron');
          status.textContent = 'Electronç¯å¢ƒ - å¯ä½¿ç”¨çœŸå®æ‰“å°æœºAPI';
          alert.className = 'alert alert-success';
          alert.innerHTML =
            '<strong>âœ… Electronç¯å¢ƒæ£€æµ‹æˆåŠŸ!</strong> å¯ä»¥ä½¿ç”¨çœŸå®çš„çƒ­æ•æ‰“å°æœºAPIè¿›è¡Œæµ‹è¯•ã€‚';
        } else {
          status.textContent = 'æµè§ˆå™¨ç¯å¢ƒ - ä»…æ¨¡æ‹ŸåŠŸèƒ½';
          alert.className = 'alert alert-warning';
          alert.innerHTML =
            '<strong>âš ï¸ æµè§ˆå™¨ç¯å¢ƒ!</strong> åœ¨æ­¤ç¯å¢ƒä¸‹åªèƒ½ä½¿ç”¨æ¨¡æ‹ŸåŠŸèƒ½ã€‚è¯·åœ¨Tauriåº”ç”¨ä¸­è¿è¡Œä»¥æµ‹è¯•çœŸå®æ‰“å°æœºã€‚';
        }

        log(`ğŸŒ ç¯å¢ƒæ£€æµ‹å®Œæˆ: ${isElectron ? 'Electron' : 'æµè§ˆå™¨'}`, 'info');
      }

      // æ£€æŸ¥Electron APIå¯ç”¨æ€§
      async function checkElectronAPIs() {
        log('ğŸ” æ£€æŸ¥Electron APIå¯ç”¨æ€§...', 'info');

        if (!window.electronAPI) {
          log('âŒ electronAPI ä¸å¯ç”¨ - è¯·åœ¨Tauriåº”ç”¨ä¸­è¿è¡Œ', 'error');
          return;
        }

        const apis = [
          'getPrinters',
          'testPrint',
          'detectChineseCharacterType',
          'getPrinterEncodingInfo',
          'testPrinterEncodingCompatibility',
          'testAllEncodingsForPrinter',
          'generateEncodingCompatibilityReport',
          'printOrderWithEncoding',
          'selectOptimalEncoding',
        ];

        let availableCount = 0;
        for (const api of apis) {
          if (typeof window.electronAPI[api] === 'function') {
            log(`âœ… ${api} - å¯ç”¨`, 'success');
            availableCount++;
          } else {
            log(`âŒ ${api} - ä¸å¯ç”¨`, 'error');
          }
        }

        log(
          `ğŸ“Š APIæ£€æŸ¥å®Œæˆ: ${availableCount}/${apis.length} ä¸ªAPIå¯ç”¨`,
          'info'
        );
        document.getElementById(
          'initResult'
        ).textContent = `APIå¯ç”¨æ€§: ${availableCount}/${apis.length}`;
      }

      // åˆå§‹åŒ–ç³»ç»Ÿ
      async function initializeSystem() {
        log('ğŸš€ å¼€å§‹åˆå§‹åŒ–ç³»ç»Ÿ...', 'info');

        try {
          if (window.electronAPI) {
            // Electronç¯å¢ƒ
            log('ğŸ”Œ Electronç¯å¢ƒï¼šåˆå§‹åŒ–çœŸå®æ‰“å°æœºç³»ç»Ÿ', 'info');
            await refreshPrinters();
          } else {
            // æµè§ˆå™¨ç¯å¢ƒ
            log('ğŸŒ æµè§ˆå™¨ç¯å¢ƒï¼šä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®', 'warning');
            printers = generateMockPrinters();
            updatePrinterGrid(printers);
          }

          log('âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'success');
          document.getElementById('initResult').textContent =
            'âœ… ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ';
        } catch (error) {
          log(`âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
          document.getElementById(
            'initResult'
          ).textContent = `âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`;
        }
      }

      // åˆ·æ–°æ‰“å°æœºåˆ—è¡¨
      async function refreshPrinters() {
        log('ğŸ”„ åˆ·æ–°æ‰“å°æœºåˆ—è¡¨...', 'info');

        try {
          if (window.electronAPI && window.electronAPI.getPrinters) {
            printers = await window.electronAPI.getPrinters();
            log(`âœ… æ£€æµ‹åˆ° ${printers.length} å°æ‰“å°æœº`, 'success');
          } else {
            printers = generateMockPrinters();
            log(`ğŸŒ ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®: ${printers.length} å°æ‰“å°æœº`, 'warning');
          }

          updatePrinterGrid(printers);
          document.getElementById(
            'printerCount'
          ).textContent = `æ‰“å°æœº: ${printers.length}å°`;
        } catch (error) {
          log(`âŒ åˆ·æ–°æ‰“å°æœºå¤±è´¥: ${error.message}`, 'error');
        }
      }

      // ç”Ÿæˆæ¨¡æ‹Ÿæ‰“å°æœºæ•°æ®
      function generateMockPrinters() {
        return [
          {
            name: 'XPrinter XP-58III (USB)',
            width: 58,
            is_default: false,
            is_enabled: false,
            font_size: 0,
          },
          {
            name: 'EPSON TM-T82III',
            width: 80,
            is_default: true,
            is_enabled: false,
            font_size: 0,
          },
        ];
      }

      // æ›´æ–°æ‰“å°æœºç½‘æ ¼æ˜¾ç¤º
      function updatePrinterGrid(printers) {
        const grid = document.getElementById('printerGrid');

        if (printers.length === 0) {
          grid.innerHTML =
            '<div class="printer-card"><div class="printer-name">æœªæ£€æµ‹åˆ°æ‰“å°æœº</div></div>';
          return;
        }

        grid.innerHTML = printers
          .map(
            (printer, index) => `
                <div class="printer-card ${
                  selectedPrinter === printer.name ? 'selected' : ''
                }" 
                     onclick="selectPrinter('${printer.name}')">
                    <div class="printer-name">ğŸ“Ÿ ${printer.name}</div>
                    <div class="printer-info">
                        <span>å®½åº¦:</span>
                        <span>${printer.width}mm</span>
                    </div>
                    <div class="printer-info">
                        <span>é»˜è®¤:</span>
                        <span>${printer.is_default ? 'æ˜¯' : 'å¦'}</span>
                    </div>
                    <div class="printer-info">
                        <span>çŠ¶æ€:</span>
                        <span>${printer.is_enabled ? 'âœ…å¯ç”¨' : 'âŒç¦ç”¨'}</span>
                    </div>
                </div>
            `
          )
          .join('');

        // æ·»åŠ é€‰ä¸­æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
                .printer-card.selected {
                    border-color: #007bff;
                    background: #e7f3ff;
                }
                .printer-card {
                    cursor: pointer;
                    transition: all 0.3s ease;
                }
                .printer-card:hover {
                    border-color: #007bff;
                    transform: translateY(-2px);
                }
            `;
        if (!document.querySelector('style[data-printer-styles]')) {
          style.setAttribute('data-printer-styles', 'true');
          document.head.appendChild(style);
        }
      }

      // é€‰æ‹©æ‰“å°æœº
      function selectPrinter(printerName) {
        selectedPrinter = printerName;
        updatePrinterGrid(printers);
        log(`ğŸ“Œ é€‰æ‹©æ‰“å°æœº: ${printerName}`, 'info');
      }

      // æµ‹è¯•é€‰ä¸­çš„æ‰“å°æœº
      async function testSelectedPrinter() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        log(`ğŸ§ª å¼€å§‹æµ‹è¯•æ‰“å°æœº: ${selectedPrinter}`, 'info');

        try {
          if (window.electronAPI && window.electronAPI.testPrint) {
            const printer = printers.find((p) => p.name === selectedPrinter);
            await window.electronAPI.testPrint(
              selectedPrinter,
              printer.width || 80,
              0
            );
            log(`âœ… æ‰“å°æœº ${selectedPrinter} æµ‹è¯•æˆåŠŸ`, 'success');
          } else {
            // æ¨¡æ‹Ÿæµ‹è¯•
            await new Promise((resolve) => setTimeout(resolve, 1000));
            log(`ğŸŒ æ¨¡æ‹Ÿæµ‹è¯•: æ‰“å°æœº ${selectedPrinter} æµ‹è¯•æˆåŠŸ`, 'warning');
          }
        } catch (error) {
          log(`âŒ æ‰“å°æœºæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // è°ƒè¯•æ‰“å°æœº
      async function debugSelectedPrinter() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        log(`ğŸ”§ å¼€å§‹è°ƒè¯•æ‰“å°æœº: ${selectedPrinter}`, 'info');

        try {
          if (window.electronAPI && window.electronAPI.debugPrinter) {
            const debugInfo = await window.electronAPI.debugPrinter(
              selectedPrinter
            );
            log(`ğŸ”§ è°ƒè¯•ä¿¡æ¯:\n${debugInfo}`, 'info');
          } else {
            log(`ğŸŒ æ¨¡æ‹Ÿè°ƒè¯•: æ‰“å°æœº ${selectedPrinter} è¿æ¥æ­£å¸¸`, 'warning');
          }
        } catch (error) {
          log(`âŒ è°ƒè¯•å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æµ‹è¯•å•ä¸€ç¼–ç 
      async function testSingleEncoding() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        const testText = document.getElementById('testText').value;
        const encoding = document.getElementById('encodingSelect').value;

        if (!testText || !encoding) {
          log('âŒ è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬å¹¶é€‰æ‹©ç¼–ç ', 'error');
          return;
        }

        log(`ğŸ§ª æµ‹è¯•ç¼–ç : ${encoding} (æ‰“å°æœº: ${selectedPrinter})`, 'info');

        try {
          let result;
          if (
            window.electronAPI &&
            window.electronAPI.testPrinterEncodingCompatibility
          ) {
            result = await window.electronAPI.testPrinterEncodingCompatibility(
              selectedPrinter,
              testText,
              encoding
            );
          } else {
            // æ¨¡æ‹Ÿæµ‹è¯•
            await new Promise((resolve) => setTimeout(resolve, 500));
            result = {
              encoding: encoding,
              score: 0.85 + Math.random() * 0.15,
              success: Math.random() > 0.2,
              error: null,
            };
          }

          displaySingleEncodingResult(result);
          log(
            `âœ… ç¼–ç æµ‹è¯•å®Œæˆ: ${encoding} - ${
              result.success ? 'æˆåŠŸ' : 'å¤±è´¥'
            }`,
            result.success ? 'success' : 'error'
          );
        } catch (error) {
          log(`âŒ ç¼–ç æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æµ‹è¯•æ‰€æœ‰ç¼–ç 
      async function testAllEncodings() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        const testText = document.getElementById('testText').value;
        if (!testText) {
          log('âŒ è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'error');
          return;
        }

        log(`ğŸ”„ å¼€å§‹æ‰¹é‡ç¼–ç æµ‹è¯• (æ‰“å°æœº: ${selectedPrinter})`, 'info');

        try {
          let results;
          if (
            window.electronAPI &&
            window.electronAPI.testAllEncodingsForPrinter
          ) {
            results = await window.electronAPI.testAllEncodingsForPrinter(
              selectedPrinter,
              testText
            );
          } else {
            // æ¨¡æ‹Ÿæµ‹è¯•
            const encodings = ['UTF8', 'GBK', 'GB18030', 'BIG5', 'GB2312'];
            results = encodings.map((encoding) => ({
              encoding: encoding,
              score: 0.7 + Math.random() * 0.3,
              success: Math.random() > 0.3,
              error:
                Math.random() > 0.7 ? `æ¨¡æ‹Ÿé”™è¯¯: ${encoding} ä¸æ”¯æŒ` : null,
            }));
            await new Promise((resolve) => setTimeout(resolve, 2000));
          }

          lastTestResults = results;
          displayAllEncodingResults(results);
          log(
            `âœ… æ‰¹é‡æµ‹è¯•å®Œæˆ: ${results.filter((r) => r.success).length}/${
              results.length
            } ç¼–ç æˆåŠŸ`,
            'success'
          );
        } catch (error) {
          log(`âŒ æ‰¹é‡æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // ç”Ÿæˆå…¼å®¹æ€§æŠ¥å‘Š
      async function generateCompatibilityReport() {
        if (lastTestResults.length === 0) {
          log('âŒ è¯·å…ˆè¿›è¡Œç¼–ç æµ‹è¯•', 'error');
          return;
        }

        log(`ğŸ“Š ç”Ÿæˆå…¼å®¹æ€§æŠ¥å‘Š (æ‰“å°æœº: ${selectedPrinter})`, 'info');

        try {
          let report;
          if (
            window.electronAPI &&
            window.electronAPI.generateEncodingCompatibilityReport
          ) {
            report =
              await window.electronAPI.generateEncodingCompatibilityReport(
                selectedPrinter,
                lastTestResults
              );
          } else {
            // æ¨¡æ‹ŸæŠ¥å‘Š
            const totalScore =
              lastTestResults.reduce((sum, r) => sum + r.score, 0) /
              lastTestResults.length;
            report = {
              printer_name: selectedPrinter,
              overall_score: totalScore,
              grade:
                totalScore >= 0.9
                  ? 'ä¼˜ç§€'
                  : totalScore >= 0.8
                  ? 'è‰¯å¥½'
                  : 'ä¸€èˆ¬',
              recommendations: [
                `æ¨èä½¿ç”¨ ${lastTestResults[0].encoding} ç¼–ç ï¼ˆè¯„åˆ†: ${(
                  lastTestResults[0].score * 100
                ).toFixed(1)}%ï¼‰`,
                'å»ºè®®å®šæœŸæµ‹è¯•ç¼–ç å…¼å®¹æ€§',
              ],
            };
          }

          displayCompatibilityReport(report);
          log(
            `âœ… å…¼å®¹æ€§æŠ¥å‘Šç”Ÿæˆå®Œæˆ: æ€»åˆ† ${(report.overall_score * 100).toFixed(
              1
            )}%`,
            'success'
          );
        } catch (error) {
          log(`âŒ ç”ŸæˆæŠ¥å‘Šå¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æ™ºèƒ½ç¼–ç é€‰æ‹©
      async function smartEncodingSelection() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        const testText = document.getElementById('testText').value;
        if (!testText) {
          log('âŒ è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'error');
          return;
        }

        log(`ğŸ¤– æ™ºèƒ½ç¼–ç é€‰æ‹© (æ‰“å°æœº: ${selectedPrinter})`, 'info');

        try {
          let optimalEncoding;
          if (window.electronAPI && window.electronAPI.selectOptimalEncoding) {
            optimalEncoding = await window.electronAPI.selectOptimalEncoding(
              testText,
              selectedPrinter
            );
          } else {
            // æ¨¡æ‹Ÿæ™ºèƒ½é€‰æ‹©
            const encodings = ['UTF8', 'GBK', 'GB18030', 'BIG5', 'GB2312'];
            optimalEncoding =
              encodings[Math.floor(Math.random() * encodings.length)];
            await new Promise((resolve) => setTimeout(resolve, 800));
          }

          log(`âœ… æ™ºèƒ½æ¨èç¼–ç : ${optimalEncoding}`, 'success');
          document.getElementById('encodingSelect').value = optimalEncoding;
          document.getElementById(
            'encodingTestResult'
          ).textContent = `ğŸ¤– æ™ºèƒ½æ¨èç¼–ç : ${optimalEncoding}\n\nå»ºè®®ä½¿ç”¨æ­¤ç¼–ç è¿›è¡Œæ‰“å°ä»¥è·å¾—æœ€ä½³æ•ˆæœã€‚`;
        } catch (error) {
          log(`âŒ æ™ºèƒ½é€‰æ‹©å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æ‰“å°æµ‹è¯•è®¢å•
      async function printTestOrder() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        log(`ğŸ–¨ï¸ å¼€å§‹æ‰“å°æµ‹è¯•è®¢å• (æ‰“å°æœº: ${selectedPrinter})`, 'info');

        const testOrder = {
          order_id: `TEST${Date.now()}`,
          recipient_name: 'å¼ ä¸‰',
          recipient_address: 'åŒ—äº¬å¸‚æœé˜³åŒºæœ›äº¬è¡—é“123å·2Bå®¤',
          rd_name: 'è€ç‹å·èœé¦†',
          dishes_array: [
            {
              dishes_name: 'éº»å©†è±†è…',
              amount: 1,
              price: '18.99',
              remark: 'ä¸è¦å¤ªè¾£',
            },
            {
              dishes_name: 'å®«ä¿é¸¡ä¸',
              amount: 1,
              price: '22.99',
              remark: 'å¤šæ”¾èŠ±ç”Ÿç±³',
            },
          ],
          total: '41.98',
        };

        try {
          if (
            window.electronAPI &&
            window.electronAPI.selectOptimalEncoding &&
            window.electronAPI.printOrderWithEncoding
          ) {
            // æ™ºèƒ½é€‰æ‹©ç¼–ç å¹¶æ‰“å°
            const orderText = extractOrderText(testOrder);
            const optimalEncoding =
              await window.electronAPI.selectOptimalEncoding(
                orderText,
                selectedPrinter
              );

            log(`ğŸ¤– æ™ºèƒ½é€‰æ‹©ç¼–ç : ${optimalEncoding}`, 'info');

            const result = await window.electronAPI.printOrderWithEncoding(
              selectedPrinter,
              testOrder,
              optimalEncoding
            );

            log(`âœ… æµ‹è¯•è®¢å•æ‰“å°æˆåŠŸ: ${result}`, 'success');
            document.getElementById(
              'printTestResult'
            ).textContent = `âœ… æ‰“å°æˆåŠŸ!\n\n${result}`;
          } else {
            // æ¨¡æ‹Ÿæ‰“å°
            await new Promise((resolve) => setTimeout(resolve, 1500));
            log(`ğŸŒ æ¨¡æ‹Ÿæ‰“å°: æµ‹è¯•è®¢å•å·²å‘é€åˆ° ${selectedPrinter}`, 'warning');
            document.getElementById(
              'printTestResult'
            ).textContent = `ğŸŒ æ¨¡æ‹Ÿæ‰“å°å®Œæˆ\n\nè®¢å•ID: ${testOrder.order_id}\næ‰“å°æœº: ${selectedPrinter}\nçŠ¶æ€: æ¨¡æ‹ŸæˆåŠŸ`;
          }
        } catch (error) {
          log(`âŒ æ‰“å°æµ‹è¯•è®¢å•å¤±è´¥: ${error.message}`, 'error');
          document.getElementById(
            'printTestResult'
          ).textContent = `âŒ æ‰“å°å¤±è´¥: ${error.message}`;
        }
      }

      // æŒ‡å®šç¼–ç æ‰“å°
      async function printWithCustomEncoding() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        const encoding = document.getElementById('encodingSelect').value;
        if (!encoding) {
          log('âŒ è¯·é€‰æ‹©ç¼–ç ', 'error');
          return;
        }

        log(
          `âš™ï¸ ä½¿ç”¨æŒ‡å®šç¼–ç æ‰“å°: ${encoding} (æ‰“å°æœº: ${selectedPrinter})`,
          'info'
        );

        const testOrder = {
          order_id: `CUSTOM${Date.now()}`,
          recipient_name: 'æå››',
          rd_name: 'æµ‹è¯•é¤å…',
          dishes_array: [
            {
              dishes_name: 'æµ‹è¯•èœå“',
              amount: 1,
              price: '1.00',
            },
          ],
          total: '1.00',
        };

        try {
          if (window.electronAPI && window.electronAPI.printOrderWithEncoding) {
            const result = await window.electronAPI.printOrderWithEncoding(
              selectedPrinter,
              testOrder,
              encoding
            );
            log(`âœ… æŒ‡å®šç¼–ç æ‰“å°æˆåŠŸ: ${result}`, 'success');
            document.getElementById(
              'printTestResult'
            ).textContent = `âœ… æŒ‡å®šç¼–ç æ‰“å°æˆåŠŸ!\n\n${result}`;
          } else {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            log(`ğŸŒ æ¨¡æ‹ŸæŒ‡å®šç¼–ç æ‰“å°: ${encoding}`, 'warning');
            document.getElementById(
              'printTestResult'
            ).textContent = `ğŸŒ æ¨¡æ‹ŸæŒ‡å®šç¼–ç æ‰“å°å®Œæˆ\n\nç¼–ç : ${encoding}\næ‰“å°æœº: ${selectedPrinter}\nçŠ¶æ€: æ¨¡æ‹ŸæˆåŠŸ`;
          }
        } catch (error) {
          log(`âŒ æŒ‡å®šç¼–ç æ‰“å°å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æ‰¹é‡æ‰“å°æµ‹è¯•
      async function batchPrintTest() {
        if (!selectedPrinter) {
          log('âŒ è¯·å…ˆé€‰æ‹©ä¸€å°æ‰“å°æœº', 'error');
          return;
        }

        log(`ğŸ“¦ å¼€å§‹æ‰¹é‡æ‰“å°æµ‹è¯• (æ‰“å°æœº: ${selectedPrinter})`, 'info');

        const orders = [
          {
            order_id: 'BATCH001',
            recipient_name: 'ç‹äº”',
            dishes_array: [{ dishes_name: 'èœå“1', amount: 1, price: '10.00' }],
            total: '10.00',
          },
          {
            order_id: 'BATCH002',
            recipient_name: 'èµµå…­',
            dishes_array: [{ dishes_name: 'èœå“2', amount: 2, price: '20.00' }],
            total: '20.00',
          },
          {
            order_id: 'BATCH003',
            recipient_name: 'é’±ä¸ƒ',
            dishes_array: [{ dishes_name: 'èœå“3', amount: 1, price: '15.00' }],
            total: '15.00',
          },
        ];

        let successCount = 0;
        let failCount = 0;

        for (let i = 0; i < orders.length; i++) {
          const order = orders[i];
          try {
            log(
              `ğŸ“¦ æ‰“å°è®¢å• ${i + 1}/${orders.length}: ${order.order_id}`,
              'info'
            );

            if (
              window.electronAPI &&
              window.electronAPI.selectOptimalEncoding &&
              window.electronAPI.printOrderWithEncoding
            ) {
              const orderText = extractOrderText(order);
              const encoding = await window.electronAPI.selectOptimalEncoding(
                orderText,
                selectedPrinter
              );
              await window.electronAPI.printOrderWithEncoding(
                selectedPrinter,
                order,
                encoding
              );
            } else {
              await new Promise((resolve) => setTimeout(resolve, 500));
            }

            successCount++;
            log(`âœ… è®¢å• ${order.order_id} æ‰“å°æˆåŠŸ`, 'success');

            // æ·»åŠ å»¶è¿Ÿé¿å…æ‰“å°æœºè¿‡è½½
            if (i < orders.length - 1) {
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }
          } catch (error) {
            failCount++;
            log(
              `âŒ è®¢å• ${order.order_id} æ‰“å°å¤±è´¥: ${error.message}`,
              'error'
            );
          }
        }

        const summary = `ğŸ“¦ æ‰¹é‡æ‰“å°å®Œæˆ!\n\næ€»è®¢å•æ•°: ${orders.length}\næˆåŠŸ: ${successCount}\nå¤±è´¥: ${failCount}`;
        log(
          summary.replace(/\n/g, ' '),
          successCount === orders.length ? 'success' : 'warning'
        );
        document.getElementById('printTestResult').textContent = summary;
      }

      // æ˜¾ç¤ºå•ä¸€ç¼–ç æµ‹è¯•ç»“æœ
      function displaySingleEncodingResult(result) {
        const resultsDiv = document.getElementById('encodingResults');
        resultsDiv.innerHTML = `
                <div class="encoding-card">
                    <h3>${result.encoding}</h3>
                    <div class="encoding-score ${getScoreClass(result.score)}">
                        ${
                          result.success
                            ? (result.score * 100).toFixed(1) + '%'
                            : 'å¤±è´¥'
                        }
                    </div>
                    <div>${getGradeText(result.score)}</div>
                    ${
                      result.error
                        ? `<div style="color: #dc3545; font-size: 0.9em; margin-top: 5px;">${result.error}</div>`
                        : ''
                    }
                </div>
            `;

        document.getElementById('encodingTestResult').textContent = `ç¼–ç : ${
          result.encoding
        }\næˆåŠŸ: ${result.success ? 'æ˜¯' : 'å¦'}\nè¯„åˆ†: ${
          result.success ? (result.score * 100).toFixed(1) + '%' : 'N/A'
        }\n${result.error ? 'é”™è¯¯: ' + result.error : ''}`;
      }

      // æ˜¾ç¤ºæ‰€æœ‰ç¼–ç æµ‹è¯•ç»“æœ
      function displayAllEncodingResults(results) {
        const resultsDiv = document.getElementById('encodingResults');
        resultsDiv.innerHTML = results
          .map(
            (result) => `
                <div class="encoding-card">
                    <h3>${result.encoding}</h3>
                    <div class="encoding-score ${getScoreClass(result.score)}">
                        ${
                          result.success
                            ? (result.score * 100).toFixed(1) + '%'
                            : 'å¤±è´¥'
                        }
                    </div>
                    <div>${getGradeText(result.score)}</div>
                    ${
                      result.error
                        ? `<div style="color: #dc3545; font-size: 0.9em; margin-top: 5px;">${result.error.substring(
                            0,
                            30
                          )}</div>`
                        : ''
                    }
                </div>
            `
          )
          .join('');

        const summary = results
          .map(
            (r) =>
              `${r.encoding}: ${
                r.success ? (r.score * 100).toFixed(1) + '%' : 'å¤±è´¥'
              }`
          )
          .join('\n');

        document.getElementById(
          'encodingTestResult'
        ).textContent = `æ‰¹é‡æµ‹è¯•ç»“æœ:\n\n${summary}\n\næˆåŠŸç‡: ${
          results.filter((r) => r.success).length
        }/${results.length}`;
      }

      // æ˜¾ç¤ºå…¼å®¹æ€§æŠ¥å‘Š
      function displayCompatibilityReport(report) {
        document.getElementById('encodingTestResult').textContent =
          `ğŸ† å…¼å®¹æ€§æŠ¥å‘Š\n\n` +
          `æ‰“å°æœº: ${report.printer_name}\n` +
          `æ€»è¯„åˆ†: ${(report.overall_score * 100).toFixed(1)}%\n` +
          `ç­‰çº§: ${report.grade}\n\n` +
          `å»ºè®®:\n${report.recommendations.join('\n')}`;
      }

      // è·å–è¯„åˆ†ç­‰çº§æ ·å¼ç±»
      function getScoreClass(score) {
        if (score >= 0.9) return 'score-excellent';
        if (score >= 0.8) return 'score-good';
        if (score >= 0.6) return 'score-fair';
        return 'score-poor';
      }

      // è·å–è¯„åˆ†ç­‰çº§æ–‡æœ¬
      function getGradeText(score) {
        if (score >= 0.9) return 'ä¼˜ç§€';
        if (score >= 0.8) return 'è‰¯å¥½';
        if (score >= 0.6) return 'ä¸€èˆ¬';
        return 'è¾ƒå·®';
      }

      // æå–è®¢å•æ–‡æœ¬
      function extractOrderText(orderData) {
        const textParts = [];
        if (orderData.recipient_name) textParts.push(orderData.recipient_name);
        if (orderData.recipient_address)
          textParts.push(orderData.recipient_address);
        if (orderData.rd_name) textParts.push(orderData.rd_name);
        if (orderData.dishes_array) {
          orderData.dishes_array.forEach((dish) => {
            if (dish.dishes_name) textParts.push(dish.dishes_name);
            if (dish.remark) textParts.push(dish.remark);
          });
        }
        return textParts.join(' ');
      }

      // æ¸…ç©ºæ—¥å¿—
      function clearLog() {
        document.getElementById('systemLog').textContent = 'æ—¥å¿—å·²æ¸…ç©º';
        log('ğŸ—‘ï¸ æ—¥å¿—å·²æ¸…ç©º', 'info');
      }

      // å¯¼å‡ºæ—¥å¿—
      function exportLog() {
        const logContent = document.getElementById('systemLog').textContent;
        const blob = new Blob([logContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `printer_test_log_${new Date()
          .toISOString()
          .slice(0, 19)
          .replace(/:/g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        log('ğŸ’¾ æ—¥å¿—å·²å¯¼å‡º', 'success');
      }

      // æ—¥å¿—è®°å½•å‡½æ•°
      function log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}`;
        const logElement = document.getElementById('systemLog');

        const entryDiv = document.createElement('div');
        entryDiv.className = `log-entry log-${type}`;
        entryDiv.textContent = logEntry;

        if (
          logElement.textContent === 'ç³»ç»Ÿå°±ç»ªï¼Œç­‰å¾…æ“ä½œ...' ||
          logElement.textContent === 'æ—¥å¿—å·²æ¸…ç©º'
        ) {
          logElement.innerHTML = '';
        }

        logElement.appendChild(entryDiv);
        logElement.scrollTop = logElement.scrollHeight;

        // æ§åˆ¶å°è¾“å‡º
        console.log(`[${type.toUpperCase()}] ${message}`);
      }
    </script>
  </body>
</html>
